#include <stdio.h>

/**
/* 关于堆排序的相关资料：
/* 维基百科堆排序：https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F
/* 图解堆排序：https://www.cnblogs.com/chengxiao/p/6129630.html
**/

void heapify(int arr[], int start, int end) {
	/************************************************************************/
	/* 二叉树的堆化――筛选算法                                                                     */
	/************************************************************************/
	int i = start; //i表示父节点的下标
	int j = 2*i; //j表示左子节点的下标
	int x = arr[i]; //x用于暂存根节点值
	while (j <= end)
	{
		if ((j < end) && (arr[j] > arr[j+1])) //找出左右子节点中最小的
		{
			j++;
		}
		if (x > arr[j])
		{
			arr[i] = arr[j];
			i = j;
			j = 2*i; //向左子节点移动
		}else {
			j = end + 1; //根小于它的子节点，退出循环
		}
	}
	arr[i] = x;

}

void heap_sort(int arr[], int len) {
	/************************************************************************/
	/* 堆排序算法――Heap Sort                                                                     */
	/************************************************************************/
	
    int i,temp;
    for(i=len/2;i>=0;i--) { //建初始堆:从第一个非叶子节点开始，并向根节点移动
        heapify(arr,i,len-1);
    }

    for(i=len-1;i>0;i--) { //进行n-1次循环堆排序
        /* 此时的二叉树为一个堆，根节点最小，将根节点的值和最后一个叶子节点的值互换 */
        temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        heapify(arr,0,i-1); //下标i-1到len-1之间的值对应的值是有序的
    }
}
