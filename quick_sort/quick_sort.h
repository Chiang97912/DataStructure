#include <stdio.h>

/*
/* url:https://blog.csdn.net/morewindows/article/details/6684558
*/

int pivot(int *arr, int start, int end) {
	/************************************************************************/
	/* 求基准数的枢点位置（枢点：枢点位置大于它之前的所有值，小于它之后的所有值）                                                                     */
	/************************************************************************/
	int i = start;
	int j = end;
	int x = arr[start]; //选取数组中最左边的元素为基准数（注：最好的选取基准数的方法是随机选取一个数）
	while (i < j)
	{
		//从右向左找小于x的数，然后将该数赋给i下标对应元素
		while (i < j && arr[j] > x)
			j--; //j向左移动

		if (i < j) //如果此时i == j说明当前选取的基准数已经为枢点
		{
			arr[i] = arr[j]; 
			i++; //i下标自，准备从左向右找大于x的数
		}
		
		//从左到右找大于x的数，然后将该数赋给j下标对应的元素
		while (i < j && arr[i] < x)
			i++; //i向右移动
		
		if (i < j)
		{
			arr[j] = arr[i];
			j--; //j下标自减，准备下一次的循环
		}
	}
	arr[i] = x; //最后的i等于j，即为枢点，将枢点值设置为基准数
	return i;
}

void quick_sort(int *arr, int start, int end) {
	/************************************************************************/
	/* 分治法实现快速排序                                                                     */
	/************************************************************************/
	if (start < end)
	{
		int p = pivot(arr, start, end); //求枢点，该枢点将数组划分成了两个分块
		quick_sort(arr, start, p - 1); //递归求左边分块的枢点
		quick_sort(arr, p + 1, end); //递归求右边分块的枢点
	}
}